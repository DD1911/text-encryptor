<!doctype html>
<html lang="de">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Sichere Text-Verschl√ºsselung ‚Äì AES & Decrypt</title>
    
    <style>
        /* DESIGN-REFERENZ:
           Das Layout orientiert sich am "Material Design" Prinzip (Karten-Layout, Schatten),
           um eine moderne und intuitive Benutzerf√ºhrung zu gew√§hrleisten.
        */
        body {
            background: #f2f5f7;
            font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            padding: 30px;
            min-height: 100vh;
        }

        .panels-wrapper {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            width: 100%;
            max-width: 1000px;
        }

        .panel {
            flex: 1;
            min-width: 300px;
            max-width: 450px;
            background: white;
            padding: 25px 20px;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.08);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .info-panel {
            width: 100%;
            max-width: 920px;
            background: #eef6ee;
            padding: 25px 20px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 8px 25px rgba(0,0,0,0.05);
            color: #222;
        }

        h2 { text-align:center; color:#2e8b57; margin-top:0; }
        label { display:block; margin-top:10px; font-weight:600; color:#333; }
        
        textarea { 
            width:100%; 
            height:80px; 
            font-family: 'Courier New', monospace; 
            font-size:14px; 
            padding:10px; 
            border-radius:8px; 
            border:1px solid #ccc; 
            resize:vertical; 
            box-sizing: border-box;
        }

        input[type="password"] { 
            width:100%; 
            padding:10px; 
            border-radius:6px; 
            border:1px solid #ccc; 
            margin-top:5px; 
            box-sizing: border-box;
        }
        
        button { 
            margin-top:15px; 
            padding:12px; 
            border-radius:8px; 
            border:none; 
            background:#2e8b57;
            color:white; 
            cursor:pointer; 
            width:100%; 
            font-weight:600; 
            font-size: 16px;
            transition: background 0.2s;
        }
        button:hover { background: #257a4a; }

        .output { 
            margin-top:15px; 
            background:#e8f0fe;
            padding:10px; 
            border-radius:8px; 
            font-family: monospace; 
            font-size: 0.9em;
            min-height:40px; 
            display:flex; 
            align-items:center; 
            justify-content:space-between; 
            word-break:break-all;
        }
        
        .copy-btn { 
            width: auto; 
            margin-top: 0; 
            background:#ddd; 
            color:#333; 
            padding: 5px 10px;
        }
        .copy-btn:hover { background: #ccc; }
    </style>
</head>
<body>

<div class="panels-wrapper">
    <div class="panel" id="encryptPanel">
        <h2>üîê Verschl√ºsseln</h2>
        <label for="encPassword">1. Passwort w√§hlen</label>
        <input type="password" id="encPassword" placeholder="Sicheres Passwort eingeben">

        <label for="plainText">2. Nachricht eingeben</label>
        <textarea id="plainText" placeholder="Geheimer Text..."></textarea>

        <button id="encryptBtn">Verschl√ºsseln</button>

        <label>Ergebnis (Chiffre + IV)</label>
        <div class="output">
            <span id="encryptedOutput">...</span>
            <button class="copy-btn" id="copyEnc" title="Kopieren">üìã</button>
        </div>
    </div>

    <div class="panel" id="decryptPanel">
        <h2>üîì Entschl√ºsseln</h2>
        <label for="decPassword">1. Passwort eingeben</label>
        <input type="password" id="decPassword" placeholder="Das gleiche Passwort wie links">

        <label for="cipherText">2. Verschl√ºsselten Code einf√ºgen</label>
        <textarea id="cipherText" placeholder="String hier einf√ºgen (Format: Chiffre::IV)"></textarea>

        <button id="decryptBtn">Entschl√ºsseln</button>

        <label>Entschl√ºsselter Klartext</label>
        <div class="output">
            <span id="decryptedOutput">...</span>
            <button class="copy-btn" id="copyDec" title="Kopieren">üìã</button>
        </div>
    </div>
</div>

<div class="info-panel">
    <h2>‚ÑπÔ∏è Funktionsweise</h2>
    <p>
        <strong>Verschl√ºsselung:</strong> AES-GCM (256 Bit)<br>
        <strong>Schl√ºsselableitung:</strong> PBKDF2 (SHA-256)<br>
        <em>Implementierung gem√§√ü Web Crypto API Standards (W3C).</em>
    </p>
</div>

<script>
    // Konstante f√ºr den Salt (in Produktion sollte dieser zuf√§llig sein)
    const FIXED_SALT = "projekt_salt_v1"; 

    /* --- HILFSFUNKTIONEN F√úR BASE64 KONVERTIERUNG ---
       Quellen: StackOverflow & MDN Guides zu ArrayBuffer Manipulation
       Notwendig, da Crypto-Operationen mit bin√§ren Daten arbeiten, HTML aber Text braucht.
    */
    function arrayBufferToBase64(buffer) {
        let binary = '';
        const bytes = new Uint8Array(buffer);
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return window.btoa(binary);
    }

    function base64ToArrayBuffer(base64) {
        const binary_string = window.atob(base64);
        const len = binary_string.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes.buffer;
    }

    /**
     * FUNKTION: deriveKeyFromPassword
     * ZIEL: Ableitung eines symmetrischen Schl√ºssels aus einem Passwort.
     * QUELLEN: https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey
     * METHODE: PBKDF2 (Password-Based Key Derivation Function 2)
     */
    async function deriveKeyFromPassword(password, salt, usage) {
        const enc = new TextEncoder();
        
        // Schritt 1: Import des Passworts als KeyMaterial
        const keyMaterial = await crypto.subtle.importKey(
            "raw", 
            enc.encode(password), 
            "PBKDF2", 
            false, 
            ["deriveKey"]
        );

        // Schritt 2: Ableitung des AES-Schl√ºssels
        // Nutzung von SHA-256 als Hash-Algorithmus (Standardempfehlung NIST)
        return await crypto.subtle.deriveKey(
            {
                name: "PBKDF2",
                salt: enc.encode(salt),
                iterations: 100000, // Hohe Iterationszahl gegen Brute-Force
                hash: "SHA-256"
            },
            keyMaterial,
            { name: "AES-GCM", length: 256 }, // AES-256 f√ºr hohe Sicherheit
            true,
            [usage]
        );
    }

    /**
     * FUNKTION: encryptText
     * ZIEL: Verschl√ºsselung mittels AES-GCM.
     * QUELLEN: https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt
     */
    async function encryptText(plainText, password) {
        const enc = new TextEncoder();
        
        // Generierung des Schl√ºssels (siehe deriveKeyFromPassword)
        const key = await deriveKeyFromPassword(password, FIXED_SALT, "encrypt");
        
        // WICHTIG: Der Initialisierungsvektor (IV) muss kryptografisch zuf√§llig sein.
        // Ein fester IV w√ºrde die Verschl√ºsselung unsicher machen (Wiederholungsangriffe).
        const iv = crypto.getRandomValues(new Uint8Array(12)); // 12 Bytes empfohlen f√ºr GCM

        const cipherBuffer = await crypto.subtle.encrypt(
            { name: "AES-GCM", iv: iv },
            key,
            enc.encode(plainText)
        );

        // R√ºckgabe als Objekt, da IV f√ºr die Entschl√ºsselung ben√∂tigt wird
        return {
            cipher: arrayBufferToBase64(cipherBuffer),
            iv: arrayBufferToBase64(iv)
        };
    }

    /**
     * FUNKTION: decryptText
     * ZIEL: Entschl√ºsselung und Integrit√§tspr√ºfung.
     */
    async function decryptText(cipherBase64, ivBase64, password) {
        const dec = new TextDecoder();

        const key = await deriveKeyFromPassword(password, FIXED_SALT, "decrypt");

        const cipherBuffer = base64ToArrayBuffer(cipherBase64);
        const ivBuffer = base64ToArrayBuffer(ivBase64);

        // Der decrypt-Aufruf wirft einen Fehler, wenn der Tag (Auth-Tag) nicht passt.
        // Das bedeutet: Falsches Passwort oder manipulierte Daten.
        const plainBuffer = await crypto.subtle.decrypt(
            { name: "AES-GCM", iv: ivBuffer },
            key,
            cipherBuffer
        );

        return dec.decode(plainBuffer);
    }

    // ============================================================
    // EVENT HANDLER & UI LOGIK
    // Struktur inspiriert durch Best-Practices f√ºr asynchrone Events
    // ============================================================

    const encryptBtn = document.getElementById("encryptBtn");
    const decryptBtn = document.getElementById("decryptBtn");
    
    encryptBtn.onclick = async () => {
        const pwd = document.getElementById("encPassword").value;
        const text = document.getElementById("plainText").value;

        if(!pwd || !text) {
            alert("Bitte Passwort und Text eingeben.");
            return;
        }

        try {
            const result = await encryptText(text, pwd);
            // Formatierung: Chiffre::IV (eigene Konvention zur einfachen √úbertragung)
            const outputString = `${result.cipher}::${result.iv}`;
            document.getElementById("encryptedOutput").textContent = outputString;
        } catch (err) {
            console.error("Fehler im Verschl√ºsselungsprozess:", err);
            alert("Fehler bei der Verschl√ºsselung.");
        }
    };

    decryptBtn.onclick = async () => {
        const pwd = document.getElementById("decPassword").value;
        const fullCipherString = document.getElementById("cipherText").value;

        if(!pwd || !fullCipherString) {
            alert("Bitte alle Felder ausf√ºllen.");
            return;
        }

        if(!fullCipherString.includes("::")) {
            alert("Ung√ºltiges Format! Erwartet wird 'Cipher::IV'.");
            return;
        }

        try {
            const parts = fullCipherString.split("::");
            const cipherPart = parts[0];
            const ivPart = parts[1];

            const plainText = await decryptText(cipherPart, ivPart, pwd);
            document.getElementById("decryptedOutput").textContent = plainText;
        } catch (err) {
            console.error("Entschl√ºsselung fehlgeschlagen:", err);
            alert("Fehler! Passwort falsch oder Daten manipuliert.");
            document.getElementById("decryptedOutput").textContent = "FEHLER";
        }
    };

    // UX-Optimierung: Kopieren per Klick
    function copyToClipboard(elementId) {
        const text = document.getElementById(elementId).textContent;
        if(text && text !== "..." && text !== "FEHLER") {
            navigator.clipboard.writeText(text).then(() => {
                alert("In Zwischenablage kopiert!");
            });
        }
    }

    document.getElementById("copyEnc").onclick = () => copyToClipboard("encryptedOutput");
    document.getElementById("copyDec").onclick = () => copyToClipboard("decryptedOutput");

</script>
</body>
</html>
